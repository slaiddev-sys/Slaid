import * as React from 'react';

// Utility function to merge classes
function cn(...classes: (string | undefined)[]): string {
  return classes.filter(Boolean).join(' ');
}

export interface TextBlockProps {
  /**
   * The text content to display
   */
  children: React.ReactNode;
  
  /**
   * Text variant - determines size, weight, and spacing
   */
  variant?: 'title' | 'heading' | 'body' | 'caption';
  
  /**
   * Text alignment
   */
  align?: 'left' | 'center' | 'right' | 'justify';
  
  /**
   * Text color (Tailwind class like 'text-red-500' or hex color like '#ff0000')
   */
  color?: string;
  
  /**
   * Font family (Google Fonts name like 'font-inter', 'font-playfair-display', etc.)
   */
  fontFamily?: string;
  
  /**
   * Additional CSS classes
   */
  className?: string;
  
  /**
   * Inline styles
   */
  style?: React.CSSProperties;
}

/**
 * TextBlock - A versatile text component optimized for AI-generated presentations
 * 
 * Supports multiple text variants with responsive design and professional typography.
 * Perfect for slide content generated by Claude Sonnet.
 * 
 * Supports both Tailwind color classes and hex color codes.
 */
export default function TextBlock({
  children,
  variant = 'body',
  align = 'left',
  color = 'text-gray-900',
  fontFamily,
  className,
  style,
}: TextBlockProps) {
  // Base styles for all variants (no line-height here to avoid conflicts)
  const baseStyles = 'transition-colors duration-200';
  
  // Alignment classes
  const alignmentClasses = {
    left: 'text-left',
    center: 'text-center',
    right: 'text-right',
    justify: 'text-justify',
  };
  
  // Variant-specific styles and semantic HTML elements - removed default margins for component independence
  const variants = {
    title: {
      element: 'h1',
      styles: 'text-4xl md:text-5xl lg:text-6xl font-bold tracking-tighter leading-[0.9]',
    },
    heading: {
      element: 'h2', 
      styles: 'text-2xl md:text-3xl lg:text-4xl font-normal tracking-tight leading-snug',
    },
    body: {
      element: 'p',
      styles: 'text-base md:text-lg leading-relaxed',
    },
    caption: {
      element: 'p',
      styles: 'text-sm md:text-base text-opacity-80 leading-relaxed',
    },
  };
  
  const variantConfig = variants[variant];
  const Element = variantConfig.element;
  
  // Determine if color is hex code or Tailwind class
  const isHexColor = color && color.startsWith('#');
  
  // Check if className contains custom font sizing
  const hasCustomFontSize = className && /text-\[\d+px\]/.test(className);
  
  // Check if className contains custom font weight
  const hasCustomFontWeight = className && /font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)/.test(className);
  
  // Ensure children is always a string to prevent [object Object] display
  const safeChildren = typeof children === 'string' ? children : 
                      typeof children === 'number' ? String(children) :
                      children?.toString() || '';

  // Debug logging for font issues
  if (fontFamily || hasCustomFontWeight) {
    console.log('ðŸŽ¨ TextBlock with special styling:', {
      children: safeChildren.substring(0, 30) + '...',
      fontFamily: fontFamily,
      hasCustomFontWeight: hasCustomFontWeight,
      className: className,
      finalClassName: 'checking...'
    });
  }
  
  // Handle custom sizing and font weight conflicts
  let variantStyles = variantConfig.styles;
  if (hasCustomFontSize || hasCustomFontWeight) {
    // COMPLETELY REPLACE variant styles with minimal non-conflicting ones - no margins for independence
    const minimalStyles = {
      // Remove default margins so caller/parent controls spacing explicitly
      title: hasCustomFontWeight ? 'tracking-tighter leading-[0.9]' : 'font-bold tracking-tighter leading-[0.9]',
      heading: hasCustomFontWeight ? 'tracking-tight leading-snug' : 'font-normal tracking-tight leading-snug', 
      body: 'leading-relaxed',
      caption: 'text-opacity-80 leading-relaxed',
    };
    
    variantStyles = minimalStyles[variant];
      
    console.log('ðŸŽ¨ Using minimal styles for custom font size/weight:', {
      originalStyles: variantConfig.styles,
      minimalStyles: variantStyles,
      hasCustomFontSize,
      hasCustomFontWeight,
      customClass: className
    });
  }
  
  // Build className - exclude color if it's a hex code
  const unresolvedClassName = cn(
    baseStyles,
    variantStyles,
    alignmentClasses[align],
    !isHexColor ? color : undefined, // Only include color in className if it's not hex
    fontFamily, // Add font family class
    className
  );

  // When a custom font weight is provided, strip any conflicting Tailwind
  // weight utilities from the assembled classes and keep only the requested one.
  // This avoids precedence issues where Tailwind's generated CSS order causes
  // an earlier default weight (e.g., font-bold) to override the custom weight.
  let finalClassName = unresolvedClassName;
  if (hasCustomFontWeight && className) {
    const weightRegex = /^(font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black))$/;
    const tokens = unresolvedClassName.split(/\s+/);
    const requestedWeight = (className.split(/\s+/).find(t => weightRegex.test(t)) ?? '').trim();
    const cleaned = tokens.filter(t => !weightRegex.test(t));
    if (requestedWeight) cleaned.push(requestedWeight);
    finalClassName = cleaned.join(' ');
  }
  
    // Extract pixel size from className for inline style fallback
  let inlineFontSize = undefined;
  if (hasCustomFontSize) {
    const match = className.match(/text-\[(\d+)px\]/);
    if (match) {
      inlineFontSize = `${match[1]}px`;
      console.log('ðŸ”§ Setting inline font size fallback:', inlineFontSize);
    }
  }
  
  // Check if className contains whitespace override
  const hasWhitespaceOverride = className && /whitespace-(normal|nowrap|pre|pre-line|pre-wrap)/.test(className);
  
  // Check if className contains line-height override
  const hasLineHeightOverride = className && /leading-(none|tight|snug|normal|relaxed|loose|\[[\d.]+\])/.test(className);
  
  // Build style object - include color if it's a hex code and font size if needed
  const computedStyle = {
    ...(isHexColor ? { color } : {}),
    ...(inlineFontSize ? { fontSize: inlineFontSize } : {}),
    // Allow infinite text expansion without affecting parent layout
    position: 'relative' as const,
    margin: 0,
    padding: 0,
    // CRITICAL: Use 'auto' width to allow infinite expansion without constraining parent
    width: 'auto',
    wordWrap: 'break-word',
    overflowWrap: 'break-word',
    // Only apply nowrap if no whitespace override is present in className
    ...(hasWhitespaceOverride ? {} : { whiteSpace: 'nowrap' }),
    // Only apply default line-height if no leading override is present in className
    ...(hasLineHeightOverride ? {} : { lineHeight: '1.4' }),
    // CRITICAL: Use 'block' instead of 'inline-block' to prevent layout pushing
    display: 'block',
    // Merge with passed style prop (style prop takes precedence)
    ...style,
  };
  
  // Debug final className and style
  if (hasCustomFontSize) {
    console.log('âœ¨ Final className:', finalClassName);
    console.log('ðŸŽ¯ Style object:', style);
  }
  
  return React.createElement(
    Element,
    {
      className: finalClassName,
      style: computedStyle,
    },
    safeChildren
  );
} 